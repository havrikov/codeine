#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
This module contains luigi tasks for evaluating the generative power of the learned decision trees.
"""

from abc import ABCMeta
from pathlib import Path
from typing import final

import luigi
import pandas as pd

from lib import utils, work_dir, execution, generation, config
from lib.utils import escape_method_name, remove_tree


class ComputePrecisionForApproach(luigi.Task, utils.MethodCSVUtils, utils.CoverageOutput, generation.WithGenerationMethodName, metaclass=ABCMeta):
    """Computes how many of the predictor-generated trees actually reach their targeted method."""

    @final
    def output(self):
        return luigi.LocalTarget(work_dir / "results" / "precision" / self.format / f"{self.subject_name}-{self.generation_method_name}.csv")

    @final
    def run(self):
        # the gzipped CSVs are structured like this: "input_file", "class_name", "method_name", "line", "instructions_missed", "instructions_hit"
        dfs = []
        method_reports = Path(self.input().path) / self.coverage_dir_name
        for method_report in method_reports.iterdir():
            target = method_report.stem.split(".")[0]
            methods = self.read_coverage_report(method_report)
            # at this point the csv is "input_file", "target", "covered"
            # escape the target to be able to match it
            methods["target"] = methods["target"].apply(escape_method_name)
            # keep only entries for the method we are interested in
            methods = methods[methods["target"] == target]
            # remember how many files we generated
            num_files = len(methods)
            # keep track in how many cases we have actually reached the method
            methods = methods.groupby(methods.target).aggregate({"covered": "sum"})
            methods["attempts"] = num_files
            # compute the success ratio aka the prediction precision
            methods["precision"] = methods["covered"] / methods["attempts"]
            dfs.append(methods)

        result = pd.concat(dfs, sort=False)
        result["generation-method"] = self.generation_method_name

        output = Path(self.output().path)
        output.parent.mkdir(parents=True, exist_ok=True)
        with output.open("w", newline="") as out:
            result.to_csv(out)


class EvaluateSubjectOnApproach(luigi.Task, utils.DynamicOutput, generation.WithGenerationMethodName, metaclass=ABCMeta):
    """Runs the given subject with the inputs generated by this task's dependency and produces a method coverage report."""

    @final
    def output(self):
        return luigi.LocalTarget(work_dir / "evaluation" / self.generation_method_name / self.format / self.subject_name)

    @final
    def run(self):
        inputs = Path(self.input().path)
        with self.dynamic_output() as out:
            yield [self.clone(execution.RunSubjectOnDirectory, input_directory=str(input_dir), report_file=str(out / input_dir.with_suffix(".csv.gz").name))
                   for input_dir in inputs.iterdir()]
        if self.generation_method_name == "random" and config.remove_randomly_generated_files:
            remove_tree(inputs)
